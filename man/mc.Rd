% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lrt.R
\name{mc}
\alias{mc}
\title{Simulações de Monte-Carlo para o teste da razão de verossimilhança generalizado.}
\usage{
mc(
  N = 1L,
  n = 50L,
  sig = 0.05,
  f,
  q,
  kicks,
  par0,
  ncores = 1L,
  p,
  bilateral = FALSE,
  step = 0.001,
  ...
)
}
\arguments{
\item{N}{Número de réplicas de Monte-Carlo a ser considerada.}

\item{n}{Tamanho da amostra a ser considerada.}

\item{sig}{Nível de significância adotado.}

\item{f}{Função densidade de probabilidade considerada no teste. Essa função deverá ser implementada conforme o exemplo abaixo.}

\item{q}{Função responsável pela geração de observações de uma variável aleatório com função densidade passada para \code{f}.}

\item{kicks}{Vetor com os chutes iniciais utilizados para a otimização.}

\item{par0}{Lista com dois elementos, sendo o primeiro um vetor com os nomes das variáveis que receberão valores fixos sob a
hipótese nula e o segundo elemendo é um outro vetor com os valores impostos às variáveis.}

\item{ncores}{Número de núcleos a ser considerado. Por padrão, \code{ncores = 1L}.}

\item{p}{Valor utilizado para controlar o parâmetro da Qui-quadrado inf.}

\item{bilateral}{Se \code{TRUE}, retorna os quantis para um teste bilateral. O padrão considera
\code{bilateral  = FALSE}.}

\item{step}{Tamanho do passo da integral numeérica responsável pela obtenção dos quantis da Qui-Quadrado inf.
O padrão considera \code{step = 1e-3}.}

\item{...}{Lista de argumetos que serão passados para a função passada à \code{q}.}
}
\value{
Retornará 0 (zero) se a estatística calculado não estiver acima do quantil da distribuição qui-quadrado e 1 (um),
caso contrário.
}
\description{
Realiza uma única iteração de um procedimento de Monte-Carlo para o teste da razão de verossimilhança generalizado. Dado um nível
de significância, será retornado 1 (um) se a estatística de teste está acima do quantil da distribuição qui-quadrado e 0 (zero),
caso contrário.
}
\examples{
pdf_ew <- function(par, x, var = NULL){
alpha <- par[1]
sigma <- par[2]
theta <- par[3]

if (is.list(var)) eval(parse(text = paste(var[[1]], " <- ", unlist(var[[2]]), sep = "")))

alpha * theta / sigma * (1 - exp(-(x / sigma) ^ alpha)) ^ (theta - 1) *
  exp(-(x / sigma) ^ alpha) * (x / sigma) ^ (alpha - 1)
}

rew <- function(n, alpha, sigma, theta){
  u <- runif(n, 0, 1)
  sigma * (-log(1 - u ^ (1 / theta))) ^ (1 / alpha)
}

set.seed(1L, kind = "L'Ecuyer-CMRG")

tictoc::tic()
result <- mc(N = 100L,
             n = 50L,
             sig = 0.05,
             f = pdf_ew,
             q = rew,
             kicks = c(1, 1, 1),
             par0 = list("theta", 1),
             ncores = 1L,
             p = 0.5,
             bilateral = FALSE,
             step = 0.001, alpha = 1, sigma = 1, theta = 1)
tictoc::toc()
}
\author{
Pedro Rafael D. Marinho
}
